#!/bin/bash
#
# Dependencias locales y remotas: ssh, scp, tar 
#   solo locales: uci, hg
#
#
#       Copyleft 2012 Guido Iribarren <guidoiribarren@buenosaireslibre.org>
#       
#       This program is free software; you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation; either version 2 of the License, or
#       (at your option) any later version.
#       
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#       
#       You should have received a copy of the GNU General Public License
#       along with this program; if not, write to the Free Software
#       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#       MA 02110-1301, USA.
#
### 
### Usage: $0 push [--no-reboot] [--wait secs] [--ip <host>] NAME [[--ip <host>] NAME] ...
###        $0 pull [--ip <host>] NAME [[--ip <host>] NAME] ...
###        $0 confirm NAME [NAME] ...
###        $0 status  NAME [NAME] ...
### 
### Manage remote uci configuration in NAME(s)
### 
###  -w, --wait NUM	  After applying configuration, wait for NUM seconds
###                     before reboot.
###  -i, --ip HOST		Push the configuration to specified IP or host.
###                     Applies only to the next NAME specified in command line.
###  -n, --no-reboot	Prevent rebooting after pushing and applying configuration.
### 
#
#

export REBOOT_WAIT=15  # in seconds #DEPRECATED
export TIMEOUT=15  # in seconds
if [ -z "$BACKUP_FILELIST" ] ; then
  export BACKUP_FILELIST="/etc/config/ /etc/dropbear/ /etc/crontabs/ /etc/firewall.user /etc/group /etc/hosts /etc/inittab /etc/passwd /etc/profile /etc/rc.local /etc/shadow /etc/shells /etc/sysctl.conf"
  export BACKUP_FILELIST="$BACKUP_FILELIST /etc/bat-hosts"
else
  echo "************ WARNING: Using filelist \"$BACKUP_FILELIST\""
fi
if [ -z "$ETC_FAILSAFE" ] ; then
  export ETC_FAILSAFE="/etc.failsafe/"
fi
export REBOOT_CMD="/sbin/reboot"
export NO_REBOOT_CMD="/bin/true"
export TAR="tar" # Use "tar -z" if you want network traffic to be compressed during pull
export CMDNAME="$(basename "$0")"
export SSH_PERSIST="ssh -o \"ControlMaster auto\" 
                    -o \"ControlPath /tmp/$CMDNAME_ssh_%r@%h:%p\"
                    -o \"ControlPersist 60\"
                    -o \"ServerAliveInterval 10\"
                    -o \"ConnectTimeout 20\"
                   "
export EPOCH="$(date +%s)"

export DIR_UCI_CONFIG="overlay/etc/config/"
export DIR_OVERLAY="overlay"
export DIR_PULL_TMP="remote.$EPOCH"

export CNAMES_PUSHED="/tmp/ruci.pushed"
export CNAMES_DIRTY="/tmp/ruci.dirty"
cat /dev/null >"${CNAMES_PUSHED:?}"
cat /dev/null >"${CNAMES_DIRTY:?}"

usage () {
  [ -n "$1" ] && echo "$@"
  sed -n "/^### /{s///;s|\$0|$CMDNAME|g;p}" "$0"
  exit 1
}

getIpFromCname () {
  CNAME="${1:?}"
  
  uci -c "$CNAME/$DIR_UCI_CONFIG" get network.lan.ipaddr
}

tstamp () {
  date +%F_%T.%3N
}

log () {
  CNAME="${1:?}"
  shift
  TEXT="$*"
  
  echo "$TEXT" \
    | sed "/tar: removing leading ... from member/d" \
    | sed "s|^|[$CNAME] $(tstamp): |" \
    | tee -a "$LOGFILE"
}
 
try () {
  CNAME="${1:?}"
  CMDLINE="${2:?}"
  CMD="${CMDLINE%% *}"
  
  ERRLOG="/tmp/$CMD.${CNAME////}.$EPOCH"
  
  eval "$CMDLINE" &> "$ERRLOG"
  RETVAL=$?
  if [ -r "$ERRLOG" ] && [ -s "$ERRLOG" ] ; then
    sed "s|^|($CMD) |" -i "$ERRLOG"
    log "$CNAME" "$(<"$ERRLOG")"
  fi
  rm -f "$ERRLOG"
  return $RETVAL
}

pullConfigFromIp () {
  CNAME="${1:?}"
  IPADDR="${2:?}"
  SKIP_UPDATE=$3
  
  RETVAL=
  
  if [ -d "$CNAME" ] && [ -z "$SKIP_UPDATE" ] && [ -n "$(hg status "$CNAME")" ] ; then
    log "$CNAME" "Directory contains uncommited changes. Autocommiting..."
    try "$CNAME" "hg commit -A -m \"Autocommit before pulling from $IPADDR\" $CNAME" \
      || return
  fi

  mkdir -p "$CNAME/$DIR_PULL_TMP"

  log "$CNAME" "Pulling $DIR_OVERLAY from $IPADDR ..."
  try "$CNAME" "ssh $IPADDR \"$TAR -c -f - /$DIR_OVERLAY \" >$CNAME/$DIR_PULL_TMP.tar" \
    || { RETVAL=$? ; rm -rf "$CNAME/$DIR_PULL_TMP"{/,.tar} ; return $RETVAL ; }
  
  try "$CNAME" "$TAR -x -f $CNAME/$DIR_PULL_TMP.tar -C $CNAME/$DIR_PULL_TMP" \
    || { RETVAL=$? ; rm -rf "$CNAME/$DIR_PULL_TMP"{/,.tar} ; return $RETVAL ; }

  rm -rf "$CNAME/$DIR_PULL_TMP.tar"

  if [ -z "$SKIP_UPDATE" ] ; then 
    rm -rf "$CNAME/$DIR_OVERLAY"
    mv "$CNAME/$DIR_PULL_TMP/$DIR_OVERLAY" "$CNAME/$DIR_OVERLAY"
    rm -rf "$CNAME/$DIR_PULL_TMP"
  fi
  
  log "$CNAME" "Pulled successfully."
}

pushConfigToIp () {
  CNAME="${1:?}"
  IPADDR="${2:?}"
  RETVAL=
  BACKUP_FILES=
  
  try "$CNAME" "ssh $IPADDR /bin/sh -c \'[ -d /etc.failsafe-to-apply/ ]\' "
    RETVAL=$?
    if [ $RETVAL -eq 0 ] ; then
      log "$CNAME" "Previous push hasn't been confirmed yet. Use \`$0 confirm $CNAME\` first. Skipping..." 
      return
    fi
  
  for file in $BACKUP_FILELIST; do
    BACKUP_FILES="$BACKUP_FILES $CNAME/$DIR_OVERLAY/$file"
  done
  
  log "$CNAME" "Sending config with scp to $IPADDR ... "
  try "$CNAME" "ssh $IPADDR \"/bin/mkdir -p /tmp/etc.new.$EPOCH\" " \
    || return
  try "$CNAME" "scp -pr $BACKUP_FILES $IPADDR:/tmp/etc.new.$EPOCH/ >/dev/null" \
    || return
  
  log "$CNAME" "Config sent. Applying changes..."
  try "$CNAME" "ssh $IPADDR \"    /bin/rm -rf /etc.failsafe/ ;
                              ( /bin/cp -a /etc /etc.failsafe \
                                && /bin/rm -rf $BACKUP_FILELIST \
                                && /bin/mv /tmp/etc.new.$EPOCH/* /etc/ ) \
                           && ( /bin/sleep $REBOOT_WAIT \
                                && $REBOOT_CMD & )\" " \
    || return

  log "$CNAME" "Done.$([ $REBOOT_CMD == $NO_REBOOT_CMD ] || echo " Rebooting in $REBOOT_WAIT secs...")"
  echo -n " $CNAME" >> "$CNAMES_PUSHED"
}

confirmConfigToIp () {
  CNAME="${1:?}"
  IPADDR="${2:?}"

  log "$CNAME" "Trying to remove $ETC_FAILSAFE in $IPADDR ... "
  try "$CNAME" "ssh $IPADDR \"/bin/rm -rfv ${ETC_FAILSAFE:?}\" " \
    || return

  log "$CNAME" "Done."
}

statusConfigFromIp () {
  CNAME="${1:?}"
  IPADDR="${2:?}"
  RETVAL=
  STATUSMSG=
  
  try "$CNAME" "pullConfigFromIp \"$CNAME\" \"$IPADDR\" skip_update" >/dev/null \
    || { log "$CNAME" "$IPADDR Down." ; return ; }

  try "$CNAME" "ssh $IPADDR /bin/sh -c \'[ -d $ETC_FAILSAFE ]\' " \
    && STATUSMSG=" Counting down to revert-to-failsafe. Use \`$0 confirm $CNAME\`." \
    && echo -n " $CNAME" >> "$CNAMES_PUSHED"
    
  try "$CNAME" "diff -q . . ; ( cd \"$CNAME\" ; find -L \"$DIR_OVERLAY\" \"$DIR_PULL_TMP/$DIR_OVERLAY\" -type l -printf \"%f\n\"\
                | diff -X - -qr \"$DIR_OVERLAY\" \"$DIR_PULL_TMP/$DIR_OVERLAY\" ) " >/dev/null
    RETVAL=$?

  rm -rf "$CNAME/$DIR_PULL_TMP"
  
  case $RETVAL in
    0) log "$CNAME" "$IPADDR Reachable and updated.$STATUSMSG" ;;
    1) log "$CNAME" "$IPADDR Reachable, with changes pending.$STATUSMSG"
       echo -n "|$CNAME" >> "$CNAMES_DIRTY" ;;
    *) log "$CNAME" "Unknown error ($RETVAL) in diff.$STATUSMSG" ;;
  esac
}

pullConfigs () {
  ARG=
  IPADDR=
  CNAME=
  
  while [ -n "$1" ]; do
    ARG="$1"
    shift
  
    case "$ARG" in
      -i|--ip ) IPADDR="$1" ; shift ;;
      * )
        CNAME="$ARG"

        if ! [ -d "$CNAME/$DIR_UCI_CONFIG" ] && [ -z "$IPADDR" ] ; then 
          log "$CNAME" "UCI config directory not found! Please prepend --ip to specify where to pull from."
          continue
        fi
	
        [ -z "$IPADDR" ] && IPADDR=$(getIpFromCname "$CNAME")
  
        pullConfigFromIp "$CNAME" "$IPADDR" &
        
        unset IPADDR
      ;;
    esac
  done
}

pushConfigsSafe () {
  ARG=
  IPADDR=
  CNAME=
    
  # Parse args and populate targets list
  while [ -n "$1" ]; do
    ARG="$1"
    shift
  
    case "$ARG" in
      -i|--ip ) IPADDR="$1"; shift ;;
      * )
        CNAME="$ARG"
          
        [ -d "$CNAME/$DIR_UCI_CONFIG" ] \
          || { log "$CNAME" "UCI config directory not found! All targets must be valid. Aborting..." ; exit 1 ; }

        [ -z "$IPADDR" ] && IPADDR=$(getIpFromCname "$CNAME")
  
        # Check local repo is clean
        [ -z "$(hg status "$CNAME")" ] \
          || { log "$CNAME" "Directory contains uncommited changes. Please commit first. Aborting..." ; exit 2 ; }
  
        unset IPADDR
      ;;
    esac
  done
  
        RETVAL=
        BACKUP_FILES=
  
        # Open ssh persistent connection
        try "$CNAME" "$SSH_PERSIST $IPADDR /bin/sh -c \'[ -d $ETC_FAILSAFE ]\' "
          RETVAL=$?
          if [ $RETVAL -eq 0 ] ; then
            log "$CNAME" "Previous push hasn't been confirmed yet. Use \`$0 confirm $CNAME\` first. Aborting..." 
            exit 3
          fi

        #   pull and check against last rev ; wait
        #      [if not clean, exit "try hg merge"]
        #   copy files ; wait ; "config sent"
        #   swap /etc /etc.fsf ; wait ; "New config in place"
        #   reboot ; "Reboot"
        # close ssh persistent connection
        # ping ; wait
        # open ssh persistent connection
        #   remove /etc.fsf
        # close ssh persist
        # save last rev name pushed
        
#####
        
        for file in $BACKUP_FILELIST; do
          BACKUP_FILES="$BACKUP_FILES $CNAME/$DIR_OVERLAY/$file"
        done
        
        log "$CNAME" "Sending config with scp to $IPADDR ... "
        try "$CNAME" "ssh $IPADDR \"/bin/mkdir -p /tmp/etc.new.$EPOCH\" " \
          || return
        try "$CNAME" "scp -pr $BACKUP_FILES $IPADDR:/tmp/etc.new.$EPOCH/ >/dev/null" \
          || return
        
        log "$CNAME" "Config sent. Applying changes..."
        try "$CNAME" "ssh $IPADDR \"    /bin/rm -rf $ETC_FAILSAFE ;
                                    ( /bin/cp -a /etc $ETC_FAILSAFE \
                                      && /bin/rm -rf $BACKUP_FILELIST \
                                      && /bin/mv /tmp/etc.new.$EPOCH/* /etc/ ) \
                                 && ( /bin/sleep $REBOOT_WAIT \
                                      && $REBOOT_CMD & )\" " \
          || return

        log "$CNAME" "Done.$([ $REBOOT_CMD == $NO_REBOOT_CMD ] || echo " Rebooting in $REBOOT_WAIT secs...")"
        echo -n " $CNAME" >> "$CNAMES_PUSHED"

####
}

pushConfigs () {
  ARG=
  IPADDR=
  CNAME=
  
  while [ -n "$1" ]; do
    ARG="$1"
    shift
  
    case "$ARG" in
      -i|--ip ) IPADDR="$1" ; shift ;;
      -n|--no-reboot ) REBOOT_CMD="$NO_REBOOT_CMD" ;;
      -w|--wait ) 
        if [ -z "${1//[0-9]/}" ] ; then
          REBOOT_WAIT=$1 ; shift
        else usage "Error: Wait delay must be an integer"
        fi
      ;;
      * )
        CNAME="$ARG"

        [ -d "$CNAME/$DIR_UCI_CONFIG" ] \
          || { log "$CNAME" "UCI config directory not found. Ignoring host." ; unset IPADDR ; continue ; }
  
        [ -z "$IPADDR" ] && IPADDR=$(getIpFromCname "$CNAME")
  
        pushConfigToIp "$CNAME" "$IPADDR" &
        
        unset IPADDR
      ;;
    esac
  done
}

confirmConfigs () {
  CNAME=
  IPADDR=
  
  while [ -n "$1" ]; do
    CNAME="$1"
    shift
  
    [ -d "$CNAME/$DIR_UCI_CONFIG" ] \
      || { log "$CNAME" "UCI config directory not found. Ignoring host." ; continue ; }
    
    IPADDR=$(getIpFromCname "$CNAME")

    confirmConfigToIp "$CNAME" "$IPADDR" &
  done
}

statusConfigs () {
  CNAME=
  IPADDR=
  
  while [ -n "$1" ]; do
    CNAME="$1"
    shift

    [ -d "$CNAME/$DIR_UCI_CONFIG" ] \
      || { log "$CNAME" "UCI config directory not found. Ignoring host." ; continue ; }
    
    IPADDR=$(getIpFromCname "$CNAME")
    
    statusConfigFromIp "$CNAME" "$IPADDR" &
  done
}

export ACTION="$1"
shift

export LOGFILE="/tmp/$CMDNAME-$ACTION.log"
rm -f "$LOGFILE"

case "$ACTION" in
  pull | push | confirm ) 
    [ -z "$*" ] && usage "Error: No NAME(s) specified on command line."
    ${ACTION}Configs "$@"
  ;;
  status )
    ${ACTION}Configs "${@:-./*/}"
  ;;
  "" ) usage ;;
  * ) usage "Error: Unknown action \"$ACTION\"" ;;
esac

log "*" "All jobs started. Sorted logfile will be written to $LOGFILE"
wait
sort "$LOGFILE" | sed "/\(Pulling\|Sending\|Trying\)/s/^/\n/" > "$LOGFILE".sort
mv -f "$LOGFILE.sort" "$LOGFILE"

echo
if [ -s "$CNAMES_DIRTY" ] ; then
  egrep "($(cat "$CNAMES_DIRTY" |sed 's/^|//'))" "$LOGFILE"
  rm -rf "${CNAMES_DIRTY:?}"
fi

if [ -s "$CNAMES_PUSHED" ] ; then
  echo "Don't forget to run \`$CMDNAME confirm $(<"$CNAMES_PUSHED")\`"
  rm -rf "${CNAMES_PUSHED:?}"
fi
