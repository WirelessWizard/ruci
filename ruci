#!/bin/bash
#
# Dependencias locales y remotas: ssh, scp, tar 
#   solo locales: uci, hg
#
#
#       Copyleft 2012 Guido Iribarren <guidoiribarren@buenosaireslibre.org>
#       
#       This program is free software; you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation; either version 2 of the License, or
#       (at your option) any later version.
#       
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#       
#       You should have received a copy of the GNU General Public License
#       along with this program; if not, write to the Free Software
#       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#       MA 02110-1301, USA.
#
### 
### Usage: $0 push [--no-reboot] [--wait secs] [--ip <host>] NAME [[--ip <host>] NAME] ...
###        $0 pull [--gzip] [--ip <host>] NAME [[--ip <host>] NAME] ...
###        $0 confirm NAME [NAME] ...
###        $0 status  NAME [NAME] ...
### 
### Manage remote uci configuration in NAME(s)
### 
###  -w, --wait NUM	  After applying configuration, wait for NUM seconds
###                     before reboot.
###  -i, --ip HOST		Push the configuration to specified IP or host.
###                     Applies only to the next NAME specified in command line.
###  -n, --no-reboot	Prevent rebooting after pushing and applying configuration.
###  -z, --gzip       Use gzip compression on incoming network traffic during pull.
###                     Better perfomance on slow links, at the expense of high cpu load.
###
#
#

export REBOOT_WAIT=15  # in seconds #DEPRECATED
export TIMEOUT=15  # in seconds
if [ -z "$PUSH_FILELIST" ] ; then
  export PUSH_FILELIST="/etc"
else
  echo "************ WARNING: Using filelist \"$PUSH_FILELIST\""
fi
if [ -z "$ETC_FAILSAFE" ] ; then
  export ETC_FAILSAFE="/etc.failsafe/"
fi
export REBOOT_CMD="/sbin/reboot"
export NO_REBOOT_CMD="/bin/true"
export TAR="tar" # This command must accept argument -z to enable gzip compression
export CMDNAME="$(basename "$0")"
export SSH_PERSIST="ssh -o \"ControlMaster auto\" \
                    -o \"ControlPath /tmp/$CMDNAME_ssh_%r@%h:%p\" \
                    -o \"ControlPersist 60\" \
                    -o \"ServerAliveInterval 10\" \
                    -o \"ConnectTimeout 20\" \
                   "
export EPOCH="$(date +%s)"

export DIR_UCI_CONFIG="overlay/etc/config/"
export DIR_OVERLAY="overlay"
export DIR_PULL_TMP="remote.$EPOCH"
export DIR_PUSH_TMP="overlay.new.$EPOCH"

export CNAMES_PUSHED="/tmp/ruci.pushed"
export CNAMES_DIRTY="/tmp/ruci.dirty"
cat /dev/null >"${CNAMES_PUSHED:?}"
cat /dev/null >"${CNAMES_DIRTY:?}"

usage () { REASON="$*"
  [ -n "$REASON" ] && echo "$REASON"
  sed -n "/^### /{s///;s|\$0|$CMDNAME|g;p}" "$0"
  exit 1
}

getIpFromUciConfig () { 
  uci -c "$DIR_UCI_CONFIG" get network.lan.ipaddr
}

repoIsClean () {
  repoIsEqualToRev "-1"
}

repoIsEqualToRev () { REV="${1:?}"
  STDOUT="$(hg status --rev $REV "$DIR_OVERLAY")" ; RETVAL=$?
  ([ -z "$STDOUT" ] && [ $RETVAL -eq 0 ]) && return 0 || return 1
}

repoAutocommit () {
  hg commit -A -m "Autocommit local changes before pulling." "$DIR_OVERLAY"
}

repoLastRev () {
  hg log --template "{node}\n" -l 1 "$DIR_OVERLAY"
}

writeLastRevPushed () {
  repoLastRev > ".lastrevpushed"
}

readLastRevPushed () {
  [ -s ".lastrevpushed" ] && cat ".lastrevpushed" || echo 0
}

tstamp () {
  date +%F_%T.%3N
}

log () { TEXT="$*"
  [ "$1" == "*" ] && CNAME="*" || CNAME="$(basename `pwd -L`)"
  echo "$TEXT" \
    | sed "/tar: removing leading ... from member/d" \
    | sed "s|^|[$CNAME] $(tstamp): |" \
    | tee -a "$LOGFILE"
}
 
try () { CMDLINE="${1:?}"
  CMD="${CMDLINE%% *}"
  CNAME="$(basename `pwd -L`)"
  ERRLOG="/tmp/$CMD.${CNAME////}.$EPOCH"
  
  eval "$CMDLINE" &> "$ERRLOG"
  RETVAL=$?
  if [ -r "$ERRLOG" ] && [ -s "$ERRLOG" ] ; then
    sed "s|^|($CMD) |" -i "$ERRLOG"
    log "$(<"$ERRLOG")"
  fi
  rm -f "$ERRLOG"
  return $RETVAL
}

pullConfigFromIp () { IPADDR="${1:?}" ; SKIP_UPDATE=$2
  RETVAL=
  
  if [ -d "$DIR_OVERLAY" ] && [ -z "$SKIP_UPDATE" ] && ! repoIsClean ; then
    log "Directory contains uncommited changes. Autocommiting..."
    try "repoAutocommit" \
      || return
  fi

  mkdir -p "$DIR_PULL_TMP"

  log "Pulling $DIR_OVERLAY from $IPADDR ..."
  try "$SSH_PERSIST $IPADDR \"$TAR -c -f - /$DIR_OVERLAY \" >$DIR_PULL_TMP.tar" \
    || { RETVAL=$? ; rm -rf "$DIR_PULL_TMP"{/,.tar} ; return $RETVAL ; }
  
  try "$TAR -x -f $DIR_PULL_TMP.tar -C $DIR_PULL_TMP" \
    || { RETVAL=$? ; rm -rf "$DIR_PULL_TMP"{/,.tar} ; return $RETVAL ; }

  rm -rf "$DIR_PULL_TMP/$DIR_OVERLAY/$ETC_FAILSAFE" # Ignore the temp $ETC_FAILSAFE on remote hosts
  rm -rf "$DIR_PULL_TMP.tar"

  if [ -z "$SKIP_UPDATE" ] ; then 
    rm -rf "$DIR_OVERLAY"
    mv "$DIR_PULL_TMP/$DIR_OVERLAY" "$DIR_OVERLAY"
    rm -rf "$DIR_PULL_TMP"
  fi
  
  log "Pulled successfully."
}

pushConfigToIp () { IPADDR="${1:?}"
  RETVAL=
  PUSH_FILES=
  
  try "$SSH_PERSIST $IPADDR /bin/sh -c \'[ -d /etc.failsafe-to-apply/ ]\' "
    RETVAL=$?
    if [ $RETVAL -eq 0 ] ; then
      log "Previous push hasn't been confirmed yet. Use \`$CMDNAME confirm [...]\` first. Skipping..." 
      return
    fi
  
  log "Sending config with scp to $IPADDR ... "
  try "$SSH_PERSIST $IPADDR \"/bin/mkdir -p /tmp/$DIR_PUSH_TMP/\" " \
    || return
  
  try "$TAR -c --owner root --group root -f $DIR_PUSH_TMP.tar -C $DIR_OVERLAY/ ./$PUSH_FILELIST" \
    || { RETVAL=$? ; rm -rf "$DIR_PUSH_TMP.tar" ; return $RETVAL ; }
  
  try "$SSH_PERSIST $IPADDR \"$TAR -x -f - -C /tmp/$DIR_PUSH_TMP/ \" <$DIR_PUSH_TMP.tar" \
    || { RETVAL=$? ; rm -rf "$DIR_PUSH_TMP.tar" ; return $RETVAL ; }
  
  rm -rf "$DIR_PUSH_TMP.tar"

  log "Config sent. Applying changes..."
  try "$SSH_PERSIST $IPADDR \"    /bin/rm -rf /etc.failsafe/ ;
                              ( /bin/cp -a /etc /etc.failsafe \
                                && /bin/rm -rf $PUSH_FILELIST \
                                && /bin/mv /tmp/$DIR_PUSH_TMP/* / ) \
                           && ( /bin/sleep $REBOOT_WAIT \
                                && $REBOOT_CMD & )\" " \
    || return

  writeLastRevPushed
  
  log "Done.$([ $REBOOT_CMD == $NO_REBOOT_CMD ] || echo " Rebooting in $REBOOT_WAIT secs...")"

  CNAME="$(basename `pwd -L`)"
  echo -n " $CNAME" >> "$CNAMES_PUSHED"
}

confirmConfigToIp () { IPADDR="${1:?}"
  log "Trying to remove $ETC_FAILSAFE in $IPADDR ... "
  try "$SSH_PERSIST $IPADDR \"/bin/rm -rfv ${ETC_FAILSAFE:?}\" " \
    || return

  log "Done."
}

statusConfigFromIp () { IPADDR="${1:?}"
  RETVAL=
  STATUSMSG=

  CNAME="$(basename `pwd -L`)"
  
  try "pullConfigFromIp \"$IPADDR\" skip_update" >/dev/null \
    || { log "$IPADDR Down." ; return ; }

  try "$SSH_PERSIST $IPADDR /bin/sh -c \'[ -d $ETC_FAILSAFE ]\' " \
    && STATUSMSG=" Counting down to revert-to-failsafe..." \
    && echo -n " $CNAME" >> "$CNAMES_PUSHED"
    
  # Compares local working copy with freshly pulled overlay. Returns 0 if they are equal, 1 if differences are found.
  try "diff -q . . ; ( find -L \"$DIR_OVERLAY\" \"$DIR_PULL_TMP/$DIR_OVERLAY\" -type l -printf \"%f\n\"\
                | diff -X - -qr \"$DIR_OVERLAY\" \"$DIR_PULL_TMP/$DIR_OVERLAY\" ) " >/dev/null
    RETVAL=$?

  # Makes the freshly pulled overlay a working copy, to compare against past revisions.
  mv "$DIR_OVERLAY" "$DIR_OVERLAY.bkp"
  mv "$DIR_PULL_TMP/$DIR_OVERLAY" "$DIR_OVERLAY"
  rm -rf "$DIR_PULL_TMP"
  
  case $RETVAL in
    0)      # Local and remote copies are equal, that means we can consider the current revision as pushed
            # even if it wasn't done with "action push". So, update LastRevPushed cookie
            # If you do "hg commit; ruci push; hg rollback; ...; hg commit", then a simple
            # "hg status" should update/fix cookies that point to vanished changeset ids.
      writeLastRevPushed
      log "$IPADDR Reachable and updated.$STATUSMSG"
    ;;
    1)      # If copies differ, might be because local has a new revision waiting to be pushed,
            # (in which case working copy is identical to the one in revision readLastRevPushed)
      if repoIsEqualToRev "$(readLastRevPushed)" ; then
        log "$IPADDR Reachable, outdated. Remote revision $(readLastRevPushed|cut -b -12).$STATUSMSG"
      else  # or else because changes happened only remotely.
        log "$IPADDR Reachable, with remote untracked changes. Please pull, manually merge and commit.$STATUSMSG"
      fi
      echo -n "|$CNAME" >> "$CNAMES_DIRTY"
    ;;
    *) log "Unknown error ($RETVAL) in diff.$STATUSMSG" ;;
  esac
  
  # Clean up the comparison scenario and leave everything as it was previously
  rm -rf "$DIR_OVERLAY"
  mv "$DIR_OVERLAY.bkp" "$DIR_OVERLAY"
}

pullConfigs () {
  ARG=
  IPADDR=
  
  while [ -n "$1" ]; do
    ARG="$1"
    shift
  
    case "$ARG" in
      -i|--ip ) IPADDR="$1" ; shift ;;
      -z|--gzip ) TAR="$TAR -z" ;;
      * )
        cd "$ARG"
          if ! [ -d "$DIR_UCI_CONFIG" ] && [ -z "$IPADDR" ] ; then 
            log "UCI config directory not found! Please prepend --ip to specify where to pull from."
            continue
          fi
    
          [ -z "$IPADDR" ] && IPADDR=$(getIpFromUciConfig)
    
          pullConfigFromIp "$IPADDR" &
        cd "$OLDPWD"
        
        unset IPADDR
      ;;
    esac
  done
}

pushConfigsSafe () {
  ARG=
  IPADDR=
    
  # Parse args and populate targets list
  while [ -n "$1" ]; do
    ARG="$1"
    shift
  
    case "$ARG" in
      -i|--ip ) IPADDR="$1"; shift ;;
      * )
        cd "$ARG"
          [ -d "$DIR_UCI_CONFIG" ] \
            || { log "UCI config directory not found! All targets must be valid. Aborting..." ; exit 1 ; }

          [ -z "$IPADDR" ] && IPADDR=$(getIpFromUciConfig)
    
          # Check local repo is clean
          if ! repoIsClean ; then
            log "Directory contains uncommited changes. Please commit first. Aborting..." ; exit 2
          fi
        cd "$OLDPWD"
        
        unset IPADDR
      ;;
    esac
  done
  
        RETVAL=
        PUSH_FILES=
  
        # Open ssh persistent connection
        try "$SSH_PERSIST $IPADDR /bin/sh -c \'[ -d $ETC_FAILSAFE ]\' "
          RETVAL=$?
          if [ $RETVAL -eq 0 ] ; then
            log "Previous push hasn't been confirmed yet. Use \`$CMDNAME confirm ...\` first. Aborting..." 
            exit 3
          fi

        #   pull and check against last rev ; wait
        #      [if not clean, exit "try hg merge"]
        #   copy files ; wait ; "config sent"
        #   swap /etc /etc.fsf ; wait ; "New config in place"
        #   reboot ; "Reboot"
        # close ssh persistent connection
        # ping ; wait
        # open ssh persistent connection
        #   remove /etc.fsf
        # close ssh persist
        # save last rev name pushed
        
#####
        
        for file in $PUSH_FILELIST; do
          PUSH_FILES="$PUSH_FILES $DIR_OVERLAY/$file"
        done
        
        log "Sending config with scp to $IPADDR ... "
        try "$SSH_PERSIST $IPADDR \"/bin/mkdir -p /tmp/etc.new.$EPOCH\" " \
          || return
        try "scp -pr $PUSH_FILES $IPADDR:/tmp/etc.new.$EPOCH/ >/dev/null" \
          || return
        
        log "Config sent. Applying changes..."
        try "$SSH_PERSIST $IPADDR \"    /bin/rm -rf $ETC_FAILSAFE ;
                                    ( /bin/cp -a /etc $ETC_FAILSAFE \
                                      && /bin/rm -rf $PUSH_FILELIST \
                                      && /bin/mv /tmp/etc.new.$EPOCH/* /etc/ ) \
                                 && ( /bin/sleep $REBOOT_WAIT \
                                      && $REBOOT_CMD & )\" " \
          || return

        log "Done.$([ $REBOOT_CMD == $NO_REBOOT_CMD ] || echo " Rebooting in $REBOOT_WAIT secs...")"
        echo -n " $CNAME" >> "$CNAMES_PUSHED"

####
}

pushConfigs () {
  ARG=
  IPADDR=
  
  while [ -n "$1" ]; do
    ARG="$1"
    shift
  
    case "$ARG" in
      -i|--ip ) IPADDR="$1" ; shift ;;
      -n|--no-reboot ) REBOOT_CMD="$NO_REBOOT_CMD" ;;
      -w|--wait ) 
        if [ -z "${1//[0-9]/}" ] ; then
          REBOOT_WAIT=$1 ; shift
        else usage "Error: Wait delay must be an integer"
        fi
      ;;
      * )
        cd "$ARG"
          [ -d "$DIR_UCI_CONFIG" ] \
            || { log "UCI config directory not found. Ignoring host." ; unset IPADDR ; continue ; }
    
          [ -z "$IPADDR" ] && IPADDR=$(getIpFromUciConfig)
    
          pushConfigToIp "$IPADDR" &
        cd "$OLDPWD"
        
        unset IPADDR
      ;;
    esac
  done
}

confirmConfigs () {
  ARG=
  IPADDR=
  
  while [ -n "$1" ]; do
    ARG="$1"
    shift
  
    cd "$ARG"
      [ -d "$DIR_UCI_CONFIG" ] \
        || { log "UCI config directory not found. Ignoring host." ; continue ; }
      
      IPADDR=$(getIpFromUciConfig)

      confirmConfigToIp "$IPADDR" &
    cd "$OLDPWD"
  done
}

statusConfigs () {
  ARG=
  IPADDR=
  
  while [ -n "$1" ]; do
    ARG="$1"
    shift

    cd "$ARG"
      [ -d "$DIR_UCI_CONFIG" ] \
        || { log "UCI config directory not found. Ignoring host." ; continue ; }
      
      IPADDR=$(getIpFromUciConfig)
      
      statusConfigFromIp "$IPADDR" &
    cd "$OLDPWD"
  done
}

export ACTION="$1"
shift

export LOGFILE="/tmp/$CMDNAME-$ACTION.log"
rm -f "$LOGFILE"

case "$ACTION" in
  pull | push | confirm ) 
    [ -z "$*" ] && usage "Error: No NAME(s) specified on command line."
    ${ACTION}Configs "$@"
  ;;
  status )
    if [ -z "$*" ] ; then 
      ${ACTION}Configs *
    else 
      ${ACTION}Configs "$@"
    fi
  ;;
  "" ) usage ;;
  * ) usage "Error: Unknown action \"$ACTION\"" ;;
esac

log "*" "All jobs started. Sorted logfile will be written to $LOGFILE"
wait
sort "$LOGFILE" | sed "/\(Pulling\|Sending\|Trying\)/s/^/\n/" > "$LOGFILE".sort
mv -f "$LOGFILE.sort" "$LOGFILE"

echo
if [ -s "$CNAMES_DIRTY" ] ; then
  egrep "($(cat "$CNAMES_DIRTY" |sed 's/^|//'))" "$LOGFILE"
  rm -rf "${CNAMES_DIRTY:?}"
fi

if [ -s "$CNAMES_PUSHED" ] ; then
  echo -e "Don't forget to run:\n$CMDNAME confirm $(<"$CNAMES_PUSHED")"
  rm -rf "${CNAMES_PUSHED:?}"
fi
